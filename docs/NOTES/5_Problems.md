## Git 練習問題：自動化 CI/CD 與 MLOps 流程

# 情境一：大型檔案誤提交與 Git LFS (CI/CD 效率)
背景： 您的機器學習專案中包含了訓練好的模型 (.joblib) 和大型的處理後資料 (.csv)。開發者 A 在完成模型訓練後，不小心將這些大型檔案直接提交並推送到 Git 儲存庫，而不是使用 Git LFS (Large File Storage) 進行管理。

問題：
儲存庫變得非常龐大，每次克隆 (clone) 或拉取 (pull) 都很慢。
CI/CD 管道在執行自動測試或模型訓練時，需要下載整個龐大的儲存庫，導致執行時間大幅增加。


解決方案實作：
安裝 Git LFS： 如果尚未安裝，請先安裝 Git LFS。
追蹤大型檔案： 配置 Git LFS 來追蹤 .joblib 和 .csv 檔案。
*注意： 這是一個破壞性操作，會重寫儲存庫歷史。在實際專案中，執行前務必備份，並告知所有協作者。

# 情境二：requirements.txt 合併衝突與 CI/CD 失敗 (CI/CD 穩定性)
背景： 您的團隊有兩位開發者。開發者 A 在 feature-A 分支上工作，新增了一個套件到 requirements.txt。同時，開發者 B 在 feature-B 分支上工作，也新增了另一個套件到 requirements.txt。現在，他們都嘗試將各自的分支合併到 main 分支。

問題：
在將 feature-A 或 feature-B 合併到 main 時，requirements.txt 發生了合併衝突。
如果衝突解決不當或被忽略，CI/CD 管道在執行自動測試或模型訓練時，會因為無法安裝所有必要的依賴項而失敗。


解決衝突：
手動編輯 requirements.txt，將兩個分支的變更都包含進來，並移除 Git 插入的衝突標記。
完成合併提交：git add requirements.txt，然後 git commit -m "Resolve merge conflict in requirements.txt"。
推送到遠端：git push origin main

# 情境三：敏感資訊洩露與歷史清除 (CI/CD 安全性)
背景： 在開發初期，一位開發者不小心將資料庫連接字串或 API 金鑰硬編碼在 src/config.py 中，並提交到 Git 儲存庫。雖然很快發現並在後續提交中移除了，但敏感資訊已經存在於 Git 的歷史記錄中。

問題：
即使在最新版本中移除了敏感資訊，但由於它存在於 Git 歷史中，任何克隆儲存庫的人仍然可以訪問到它。
CI/CD 管道在執行時，如果意外地訪問了歷史版本，或被惡意利用，敏感資訊仍然有洩露的風險。


解決方案實作：
使用 git filter-repo 清除歷史： 這是從整個 Git 歷史中徹底移除特定文件或內容的推薦方法。
*注意： 這是一個破壞性操作，會重寫儲存庫歷史。在實際專案中，執行前務必備份，並告知所有協作者。

# 情境四：基於資料漂移的自動回訓觸發 (MLOps 監控與自動化)
背景： 您的機器學習模型已經部署在生產環境中，並且有一個監控系統在持續追蹤模型的效能和輸入資料的特性。監控系統檢測到生產資料發生了顯著漂移，或者模型效能下降到預設的閾值以下，需要觸發模型回訓。

問題：
如何將監控系統的警報轉化為一個自動觸發模型回訓的機制？
如何在 Git 驅動的 CI/CD 管道中實現這個「自動回訓」的觸發？


解決方案實作：
這個解決方案的核心是利用 Git 儲存庫中的一個配置旗標作為觸發器，並結合 CI/CD 管道對該旗標變更的監聽。
步驟一：定義 Git 驅動的觸發器
在您的專案配置檔案（例如 src/config.py）中，引入一個布林型態的旗標，例如命名為 RETRAIN_REQUIRED，初始值設為 False。這個旗標的作用是明確指示是否需要觸發模型回訓。
步驟二：配置 CI/CD 管道以響應觸發器
您的 CI/CD 系統（例如 GitHub Actions, Jenkins, GitLab CI 等）需要被配置來監聽 main 分支上的 push 事件
步驟三：回訓後續處理與旗標重置
為了確保流程的完整性和避免不必要的重複回訓，回訓成功後需要執行清理工作：模型版本化與保存、重置旗標、部署新模型


